#!/usr/bin/env node

//
// This NodeJS script generates the R function for the jellyfisher package based
// on the JSON schema and the table descriptions in the README.md file.
//
// Usage: node generate-R-code.mjs
//

import * as fs from "fs";

function processMarkdownLinks(text) {
  // Replace markdown links [text](url) with Roxygen2 links \href{url}{text}
  return text.replace(
    /\[([^\]]+)\]\(([^)]+)\)/g,
    (match, text, url) => `\\href{${url}}{${text}}`
  );
}

function extractTableDescriptions(readme) {
  const sections = {};
  const regex =
    /### `([^`]+)`\n\n([\s\S]*?)#### Columns\n\n([\s\S]*?)(\n\n#### Example|$)/g;

  let match;
  while ((match = regex.exec(readme)) !== null) {
    const tableName = match[1];
    const intermediateText = processMarkdownLinks(match[2].trim()); // Process links
    const columnsSection = match[3]
      .trim()
      .split("\n")
      .filter((line) => line.startsWith("- "));

    const columns = columnsSection
      .map((line) => {
        const columnMatch = line.match(/- `([^`]+)` \(([^)]+)\): (.+)/);
        if (!columnMatch) return null;

        const [, column, type, description] = columnMatch;
        return `#'   \\item{${column}}{${processMarkdownLinks(
          description.replace(/\n/g, " ").trim()
        )} (${type})}`;
      })
      .filter(Boolean)
      .join("\n");

    // Include intermediate text and column descriptions
    sections[tableName] = {
      description: intermediateText ? `#' ${intermediateText}` : null,
      columns,
    };
  }

  return sections;
}

function generateRFunction(schema, tableDescriptions) {
  const buildParamDoc = (tableName) => {
    const table = tableDescriptions[tableName];
    if (!table) return "";
    const columns = table.columns || "";
    return `#'   \\describe{\n${columns}\n#'   }`;
  };

  const properties = schema.definitions.LayoutProperties.properties;

  // Extract defaults and validation logic
  const defaults = [];
  const validations = [];
  const roxygenOptions = [];

  for (const [key, value] of Object.entries(properties)) {
    const defaultValue =
      value.default === true
        ? "TRUE"
        : value.default === false
        ? "FALSE"
        : value.default !== undefined
        ? JSON.stringify(value.default)
        : "NULL";
    defaults.push(`    ${key} = ${defaultValue}`);

    let validation = `  if (!is.null(options$${key})) {`;
    if (value.type === "number") {
      validation += `\n    if (!is.numeric(options$${key})) stop("${key} must be numeric")`;
      if (value.minimum !== undefined) {
        validation += `\n    if (options$${key} < ${value.minimum}) stop("${key} must be at least ${value.minimum}")`;
      }
      if (value.maximum !== undefined) {
        validation += `\n    if (options$${key} > ${value.maximum}) stop("${key} must be no greater than ${value.maximum}")`;
      }
    } else if (value.type === "boolean") {
      validation += `\n    if (!is.logical(options$${key})) stop("${key} must be a boolean (TRUE or FALSE)")`;
    } else if (value.type === "string" && value.enum) {
      const enumValues = value.enum.map((v) => `"${v}"`).join(", ");
      validation += `\n    if (!options$${key} %in% c(${enumValues})) stop("${key} must be one of: ${value.enum.join(
        ", "
      )}")`;
    }

    validation += "\n  }";
    validations.push(validation);

    // Documentation
    roxygenOptions.push(
      `#'   \\item{${key}}{${value.description
        .replace(/\n/g, " ")
        .replace(/\s+/g, " ")
        .trim()} Defaults to \\code{${defaultValue}}.}`
    );
  }

  // Generate R function
  return `
# Auto-generated by generate-R-code.mjs
# Do not edit this file manually

#' Creates a Jellyfish plot
#'
#' Creates a Jellyfish plot from samples, a phylogeny, and subclonal compositions.
#'
#' The format of the data frames is described with examples in Jellyfish documentation:
#' https://github.com/HautaniemiLab/jellyfish?tab=readme-ov-file#input-data
#'
#' @param samples A data frame with samples
${buildParamDoc("samples.tsv")}
#' @param phylogeny A data frame with phylogeny
${buildParamDoc("phylogeny.tsv")}
#' @param compositions A data frame with subclonal compositions
${buildParamDoc("compositions.tsv")}
#' @param options A named list of options to configure the plot. Available options:
#'   \\describe{
${roxygenOptions.join("\n")}
#'   }
#' @param ranks An optional parameter for additional ranks
#' @param controls An optional parameter to set the initial state of the controls. Can be "open", "closed", or "hidden".
#' @param width The width of the widget
#' @param height The height of the widget
#' @param elementId An optional element ID for the widget
#'
#' @examples
#' # Plot the bundled example data
#' jellyfisher(samples = samples.example,
#'             phylogeny = phylogeny.example,
#'             compositions = compositions.example,
#'             options = list(
#'               sampleHeight = 70,
#'               sampleTakenGuide = "none",
#'               showLegend = FALSE
#'             ))
#'
#' @import htmlwidgets
#' @export
jellyfisher <- function(samples,
                        phylogeny,
                        compositions,
                        options = list(),
                        ranks = NULL,
                        controls = "closed",
                        width = NULL,
                        height = NULL,
                        elementId = NULL) {
  # Define default options
  defaultOptions <- list(
${defaults.join(",\n")}
  )

  # Merge user options with defaults
  options <- modifyList(defaultOptions, options)

  # Validate options
${validations.join("\n")}

  # Forward options using x
  x <- list(
    samples = samples,
    phylogeny = phylogeny,
    compositions = compositions,
    ranks = ranks,
    options = options,
    controls = controls 
  )

  # Create widget
  htmlwidgets::createWidget(
    name = "jellyfisher",
    x,
    width = width,
    height = height,
    package = "jellyfisher",
    elementId = elementId,
    sizingPolicy = htmlwidgets::sizingPolicy(
      viewer.padding = 0,
      viewer.fill = TRUE,
      defaultWidth = "100%",
      defaultHeight = "500px"
    )
  )
}

#' Shiny bindings for jellyfisher
#'
#' Output and render functions for using jellyfisher within Shiny
#' applications and interactive Rmd documents.
#'
#' @param outputId output variable to read from
#' @param width,height Must be a valid CSS unit (like \\code{'100\\%'},
#'   \\code{'400px'}, \\code{'auto'}) or a number, which will be coerced to a
#'   string and have \\code{'px'} appended.
#' @param expr An expression that generates a jellyfisher
#' @param env The environment in which to evaluate \\code{expr}.
#' @param quoted Is \\code{expr} a quoted expression (with \\code{quote()})? This
#'   is useful if you want to save an expression in a variable.
#'
#' @name jellyfisher-shiny
#'
#' @export
jellyfisherOutput <- function(outputId, width = "100%", height = "400px") {
  htmlwidgets::shinyWidgetOutput(outputId, "jellyfisher", width, height, package = "jellyfisher")
}

#' @rdname jellyfisher-shiny
#' @export
renderJellyfisher <- function(expr, env = parent.frame(), quoted = FALSE) {
  if (!quoted) {
    expr <- substitute(expr)
  } # force quoted
  htmlwidgets::shinyRenderWidget(expr, jellyfisherOutput, env, quoted = TRUE)
}

`;
}

const readme = fs.readFileSync("jellyfish/README.md", "utf8");
const tableDescriptions = extractTableDescriptions(readme);

// Read the JSON schema
const schema = JSON.parse(
  fs.readFileSync("jellyfish/dist/schema.json", "utf8")
);

// Generate the R function
const rFunction = generateRFunction(schema, tableDescriptions);

// Write the R function to a file
fs.writeFileSync("../R/jellyfisher.R", rFunction);

console.log("R function generated successfully!");
