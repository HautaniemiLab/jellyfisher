import * as fs from "fs";

function generateRFunction(schema) {
  const properties = schema.definitions.LayoutProperties.properties;

  // Extract defaults and validation logic
  const defaults = [];
  const validations = [];
  const roxygenOptions = [];

  for (const [key, value] of Object.entries(properties)) {
    const defaultValue =
      value.default === true
        ? "TRUE"
        : value.default === false
        ? "FALSE"
        : value.default !== undefined
        ? JSON.stringify(value.default)
        : "NULL";
    defaults.push(`    ${key} = ${defaultValue}`);

    let validation = `  if (!is.null(options$${key})) {`;
    if (value.type === "number") {
      validation += `\n    if (!is.numeric(options$${key})) stop("${key} must be numeric");`;
      if (value.minimum !== undefined) {
        validation += `\n    if (options$${key} < ${value.minimum}) stop("${key} must be at least ${value.minimum}");`;
      }
      if (value.maximum !== undefined) {
        validation += `\n    if (options$${key} > ${value.maximum}) stop("${key} must be no greater than ${value.maximum}");`;
      }
    } else if (value.type === "boolean") {
      validation += `\n    if (!is.logical(options$${key})) stop("${key} must be a boolean (TRUE or FALSE)");`;
    } else if (value.type === "string" && value.enum) {
      const enumValues = value.enum.map((v) => `"${v}"`).join(", ");
      validation += `\n    if (!options$${key} %in% c(${enumValues})) stop("${key} must be one of: ${value.enum.join(
        ", "
      )}");`;
    }

    validation += "\n  }";
    validations.push(validation);

    // Documentation
    roxygenOptions.push(
      `#'   \\item{${key}}{${value.description
        .replace(/\n/g, " ")
        .replace(/\s+/g, " ")
        .trim()} Defaults to \\code{${defaultValue}}.}`
    );
  }

  // Generate R function
  return `
# Auto-generated by generate-R-code.mjs
# Do not edit this file manually

#' Creates a Jellyfish plot
#'
#' Creates a Jellyfish plot from samples, a phylogeny, and subclonal compositions.
#' The format of the data frames is described in Jellyfish documentation:
#' https://github.com/HautaniemiLab/jellyfish?tab=readme-ov-file#input-data
#'
#' @param samples A data frame with samples
#' @param phylogeny A data frame with phylogeny
#' @param compositions A data frame with subclonal compositions
#' @param options A named list of options to configure the plot. Available options:
#'   \\describe{
${roxygenOptions.join("\n")}
#'   }
#' @param ranks An optional parameter for additional ranks
#' @param width The width of the widget
#' @param height The height of the widget
#' @param elementId An optional element ID for the widget
#'
#' @import htmlwidgets
#' @export
jellyfisher <- function(samples, phylogeny, compositions, options = list(), ranks = NULL, width = NULL, height = NULL, elementId = NULL) {
  # Define default options
  defaultOptions <- list(
${defaults.join(",\n")}
  )

  # Merge user options with defaults
  options <- modifyList(defaultOptions, options)

  # Validate options
${validations.join("\n")}

  # Forward options using x
  x <- list(
    samples = samples,
    phylogeny = phylogeny,
    compositions = compositions,
    ranks = ranks,
    options = options
  )

  # Create widget
  htmlwidgets::createWidget(
    name = "jellyfisher",
    x,
    width = width,
    height = height,
    package = "jellyfisher",
    elementId = elementId
  )
}

#' Shiny bindings for jellyfisher
#'
#' Output and render functions for using jellyfisher within Shiny
#' applications and interactive Rmd documents.
#'
#' @param outputId output variable to read from
#' @param width,height Must be a valid CSS unit (like \\code{'100\\%'},
#'   \\code{'400px'}, \\code{'auto'}) or a number, which will be coerced to a
#'   string and have \\code{'px'} appended.
#' @param expr An expression that generates a jellyfisher
#' @param env The environment in which to evaluate \\code{expr}.
#' @param quoted Is \\code{expr} a quoted expression (with \\code{quote()})? This
#'   is useful if you want to save an expression in a variable.
#'
#' @name jellyfisher-shiny
#'
#' @export
jellyfisherOutput <- function(outputId, width = "100%", height = "400px") {
  htmlwidgets::shinyWidgetOutput(outputId, "jellyfisher", width, height, package = "jellyfisher")
}

#' @rdname jellyfisher-shiny
#' @export
renderJellyfisher <- function(expr, env = parent.frame(), quoted = FALSE) {
  if (!quoted) {
    expr <- substitute(expr)
  } # force quoted
  htmlwidgets::shinyRenderWidget(expr, jellyfisherOutput, env, quoted = TRUE)
}

`;
}

// Read the JSON schema
const schema = JSON.parse(
  fs.readFileSync("jellyfish/dist/schema.json", "utf8")
);

// Generate the R function
const rFunction = generateRFunction(schema);

// Write the R function to a file
fs.writeFileSync("../R/jellyfisher.R", rFunction);

console.log("R function generated successfully!");
